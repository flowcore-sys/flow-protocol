/* Auto-generated from keccak256.cl - DO NOT EDIT */
"/**\n"
" * FTC OpenCL Keccak-256 Mining Kernel\n"
" *\n"
" * High-performance GPU mining for AMD/Intel cards.\n"
" * Implements double Keccak-256 for FTC Proof of Work.\n"
" */\n"
"\n"
"/*==============================================================================\n"
" * KECCAK CONSTANTS\n"
" *============================================================================*/\n"
"\n"
"__constant ulong RC[24] = {\n"
"    0x0000000000000001UL, 0x0000000000008082UL,\n"
"    0x800000000000808aUL, 0x8000000080008000UL,\n"
"    0x000000000000808bUL, 0x0000000080000001UL,\n"
"    0x8000000080008081UL, 0x8000000000008009UL,\n"
"    0x000000000000008aUL, 0x0000000000000088UL,\n"
"    0x0000000080008009UL, 0x000000008000000aUL,\n"
"    0x000000008000808bUL, 0x800000000000008bUL,\n"
"    0x8000000000008089UL, 0x8000000000008003UL,\n"
"    0x8000000000008002UL, 0x8000000000000080UL,\n"
"    0x000000000000800aUL, 0x800000008000000aUL,\n"
"    0x8000000080008081UL, 0x8000000000008080UL,\n"
"    0x0000000080000001UL, 0x8000000080008008UL\n"
"};\n"
"\n"
"/*==============================================================================\n"
" * HELPER MACROS\n"
" *============================================================================*/\n"
"\n"
"#define ROTL64(x, n) (((x) << (n)) | ((x) >> (64 - (n))))\n"
"\n"
"/*==============================================================================\n"
" * KECCAK-F[1600] PERMUTATION\n"
" *============================================================================*/\n"
"\n"
"void keccak_f1600(ulong* state)\n"
"{\n"
"    ulong t, bc[5];\n"
"\n"
"    #pragma unroll\n"
"    for (int round = 0; round < 24; round++) {\n"
"        /* Theta */\n"
"        bc[0] = state[0] ^ state[5] ^ state[10] ^ state[15] ^ state[20];\n"
"        bc[1] = state[1] ^ state[6] ^ state[11] ^ state[16] ^ state[21];\n"
"        bc[2] = state[2] ^ state[7] ^ state[12] ^ state[17] ^ state[22];\n"
"        bc[3] = state[3] ^ state[8] ^ state[13] ^ state[18] ^ state[23];\n"
"        bc[4] = state[4] ^ state[9] ^ state[14] ^ state[19] ^ state[24];\n"
"\n"
"        t = bc[4] ^ ROTL64(bc[1], 1);\n"
"        state[0] ^= t; state[5] ^= t; state[10] ^= t; state[15] ^= t; state[20] ^= t;\n"
"        t = bc[0] ^ ROTL64(bc[2], 1);\n"
"        state[1] ^= t; state[6] ^= t; state[11] ^= t; state[16] ^= t; state[21] ^= t;\n"
"        t = bc[1] ^ ROTL64(bc[3], 1);\n"
"        state[2] ^= t; state[7] ^= t; state[12] ^= t; state[17] ^= t; state[22] ^= t;\n"
"        t = bc[2] ^ ROTL64(bc[4], 1);\n"
"        state[3] ^= t; state[8] ^= t; state[13] ^= t; state[18] ^= t; state[23] ^= t;\n"
"        t = bc[3] ^ ROTL64(bc[0], 1);\n"
"        state[4] ^= t; state[9] ^= t; state[14] ^= t; state[19] ^= t; state[24] ^= t;\n"
"\n"
"        /* Rho + Pi */\n"
"        t = state[1];\n"
"        state[1]  = ROTL64(state[6], 44);\n"
"        state[6]  = ROTL64(state[9], 20);\n"
"        state[9]  = ROTL64(state[22], 61);\n"
"        state[22] = ROTL64(state[14], 39);\n"
"        state[14] = ROTL64(state[20], 18);\n"
"        state[20] = ROTL64(state[2], 62);\n"
"        state[2]  = ROTL64(state[12], 43);\n"
"        state[12] = ROTL64(state[13], 25);\n"
"        state[13] = ROTL64(state[19], 8);\n"
"        state[19] = ROTL64(state[23], 56);\n"
"        state[23] = ROTL64(state[15], 41);\n"
"        state[15] = ROTL64(state[4], 27);\n"
"        state[4]  = ROTL64(state[24], 14);\n"
"        state[24] = ROTL64(state[21], 2);\n"
"        state[21] = ROTL64(state[8], 55);\n"
"        state[8]  = ROTL64(state[16], 45);\n"
"        state[16] = ROTL64(state[5], 36);\n"
"        state[5]  = ROTL64(state[3], 28);\n"
"        state[3]  = ROTL64(state[18], 21);\n"
"        state[18] = ROTL64(state[17], 15);\n"
"        state[17] = ROTL64(state[11], 10);\n"
"        state[11] = ROTL64(state[7], 6);\n"
"        state[7]  = ROTL64(state[10], 3);\n"
"        state[10] = ROTL64(t, 1);\n"
"\n"
"        /* Chi */\n"
"        bc[0] = state[0]; bc[1] = state[1]; bc[2] = state[2]; bc[3] = state[3]; bc[4] = state[4];\n"
"        state[0] ^= (~bc[1]) & bc[2];\n"
"        state[1] ^= (~bc[2]) & bc[3];\n"
"        state[2] ^= (~bc[3]) & bc[4];\n"
"        state[3] ^= (~bc[4]) & bc[0];\n"
"        state[4] ^= (~bc[0]) & bc[1];\n"
"\n"
"        bc[0] = state[5]; bc[1] = state[6]; bc[2] = state[7]; bc[3] = state[8]; bc[4] = state[9];\n"
"        state[5] ^= (~bc[1]) & bc[2];\n"
"        state[6] ^= (~bc[2]) & bc[3];\n"
"        state[7] ^= (~bc[3]) & bc[4];\n"
"        state[8] ^= (~bc[4]) & bc[0];\n"
"        state[9] ^= (~bc[0]) & bc[1];\n"
"\n"
"        bc[0] = state[10]; bc[1] = state[11]; bc[2] = state[12]; bc[3] = state[13]; bc[4] = state[14];\n"
"        state[10] ^= (~bc[1]) & bc[2];\n"
"        state[11] ^= (~bc[2]) & bc[3];\n"
"        state[12] ^= (~bc[3]) & bc[4];\n"
"        state[13] ^= (~bc[4]) & bc[0];\n"
"        state[14] ^= (~bc[0]) & bc[1];\n"
"\n"
"        bc[0] = state[15]; bc[1] = state[16]; bc[2] = state[17]; bc[3] = state[18]; bc[4] = state[19];\n"
"        state[15] ^= (~bc[1]) & bc[2];\n"
"        state[16] ^= (~bc[2]) & bc[3];\n"
"        state[17] ^= (~bc[3]) & bc[4];\n"
"        state[18] ^= (~bc[4]) & bc[0];\n"
"        state[19] ^= (~bc[0]) & bc[1];\n"
"\n"
"        bc[0] = state[20]; bc[1] = state[21]; bc[2] = state[22]; bc[3] = state[23]; bc[4] = state[24];\n"
"        state[20] ^= (~bc[1]) & bc[2];\n"
"        state[21] ^= (~bc[2]) & bc[3];\n"
"        state[22] ^= (~bc[3]) & bc[4];\n"
"        state[23] ^= (~bc[4]) & bc[0];\n"
"        state[24] ^= (~bc[0]) & bc[1];\n"
"\n"
"        /* Iota */\n"
"        state[0] ^= RC[round];\n"
"    }\n"
"}\n"
"\n"
"/*==============================================================================\n"
" * KECCAK-256 HASH (80-byte input)\n"
" *============================================================================*/\n"
"\n"
"void keccak256_80(__private const uchar* data, __private uchar* hash)\n"
"{\n"
"    ulong state[25] = {0};\n"
"\n"
"    /* Absorb 80 bytes (rate = 136 bytes) */\n"
"    #pragma unroll\n"
"    for (int i = 0; i < 10; i++) {\n"
"        state[i] = ((__private const ulong*)data)[i];\n"
"    }\n"
"\n"
"    /* Padding: 0x01 at byte 80, 0x80 at byte 135 */\n"
"    state[10] ^= 0x01UL;\n"
"    state[16] ^= 0x8000000000000000UL;\n"
"\n"
"    keccak_f1600(state);\n"
"\n"
"    /* Extract 256 bits */\n"
"    #pragma unroll\n"
"    for (int i = 0; i < 4; i++) {\n"
"        ((__private ulong*)hash)[i] = state[i];\n"
"    }\n"
"}\n"
"\n"
"/*==============================================================================\n"
" * KECCAK-256 HASH (32-byte input)\n"
" *============================================================================*/\n"
"\n"
"void keccak256_32(__private const uchar* data, __private uchar* hash)\n"
"{\n"
"    ulong state[25] = {0};\n"
"\n"
"    /* Absorb 32 bytes */\n"
"    #pragma unroll\n"
"    for (int i = 0; i < 4; i++) {\n"
"        state[i] = ((__private const ulong*)data)[i];\n"
"    }\n"
"\n"
"    /* Padding: 0x01 at byte 32, 0x80 at byte 135 */\n"
"    state[4] ^= 0x01UL;\n"
"    state[16] ^= 0x8000000000000000UL;\n"
"\n"
"    keccak_f1600(state);\n"
"\n"
"    /* Extract 256 bits */\n"
"    #pragma unroll\n"
"    for (int i = 0; i < 4; i++) {\n"
"        ((__private ulong*)hash)[i] = state[i];\n"
"    }\n"
"}\n"
"\n"
"/*==============================================================================\n"
" * DOUBLE KECCAK-256 MINING KERNEL\n"
" *============================================================================*/\n"
"\n"
"__kernel void keccak256_mine(\n"
"    __global const uchar* header,       /* 80-byte header (nonce at 76-79) */\n"
"    __global const uchar* target,       /* 32-byte target */\n"
"    const uint nonce_start,\n"
"    __global uint* result_nonce,\n"
"    __global uchar* result_hash,\n"
"    __global uint* found\n"
")\n"
"{\n"
"    uint gid = get_global_id(0);\n"
"    uint nonce = nonce_start + gid;\n"
"\n"
"    /* Copy header to private memory and set nonce */\n"
"    uchar local_header[80];\n"
"    #pragma unroll\n"
"    for (int i = 0; i < 76; i++) {\n"
"        local_header[i] = header[i];\n"
"    }\n"
"    local_header[76] = (uchar)(nonce);\n"
"    local_header[77] = (uchar)(nonce >> 8);\n"
"    local_header[78] = (uchar)(nonce >> 16);\n"
"    local_header[79] = (uchar)(nonce >> 24);\n"
"\n"
"    /* Double Keccak-256 */\n"
"    uchar hash1[32], hash2[32];\n"
"    keccak256_80(local_header, hash1);\n"
"    keccak256_32(hash1, hash2);\n"
"\n"
"    /* Compare with target (big-endian comparison) */\n"
"    bool valid = true;\n"
"    #pragma unroll\n"
"    for (int i = 31; i >= 0; i--) {\n"
"        if (hash2[i] < target[i]) break;\n"
"        if (hash2[i] > target[i]) { valid = false; break; }\n"
"    }\n"
"\n"
"    if (valid) {\n"
"        if (atomic_cmpxchg(found, 0, 1) == 0) {\n"
"            *result_nonce = nonce;\n"
"            #pragma unroll\n"
"            for (int i = 0; i < 32; i++) {\n"
"                result_hash[i] = hash2[i];\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
""
